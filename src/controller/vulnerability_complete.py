import socket
import threading
import queue
import ipaddress
from concurrent.futures import ThreadPoolExecutor

from rich.console import Console
from rich.table import Table
import json
from datetime import datetime

from src.controller.vulnerability_scanner import VulnerabilityScanner


class NetworkDiscovery:
    def __init__(self):
        self.active_hosts = queue.Queue()
        self.console = Console()

    def discover_host(self, ip):
        try:
            # Intenta conectarse al host usando ICMP (ping)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((str(ip), 445))  # Puerto común para verificar actividad
            sock.close()

            if result == 0:
                self.console.print(f"[green]Host activo encontrado:[/green] {ip}")
                self.active_hosts.put(str(ip))
        except:
            pass

    def scan_network(self, network):
        """
        Escanea toda la red en busca de hosts activos
        network: string en formato CIDR (ej: '192.168.1.0/24')
        """
        try:
            network = ipaddress.ip_network(network)
            self.console.print(f"[yellow]Escaneando red {network}...[/yellow]")

            # Usar ThreadPoolExecutor para escanear la red
            with ThreadPoolExecutor(max_workers=100) as executor:
                executor.map(self.discover_host, network.hosts())

            # Convertir la cola a lista para retornar
            active_hosts = []
            while not self.active_hosts.empty():
                active_hosts.append(self.active_hosts.get())

            return active_hosts
        except Exception as e:
            self.console.print(f"[red]Error al escanear la red: {str(e)}[/red]")
            return []


class NetworkScanner:
    def __init__(self):
        self.ports_queue = queue.Queue()
        self.open_ports = []
        self.services_info = []
        self.rate_limit = {'last_request': datetime.now(), 'requests': 0}
        self.console = Console()

    def port_scan(self, host, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            if result == 0:
                try:
                    sock.send(b'GET / HTTP/1.1\r\n\r\n')
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                except:
                    banner = "Banner no disponible"

                try:
                    service = socket.getservbyport(port, 'tcp')
                except:
                    service = "desconocido"

                self.services_info.append({
                    'host': host,
                    'port': port,
                    'service': service,
                    'banner': banner
                })
                self.open_ports.append(port)
                self.console.print(f"[green]Puerto {port} abierto en {host}[/green]")
            sock.close()
        except:
            pass

        self.ports_queue.task_done()

    def scan_specific_ports(self, hosts, ports):
        """
        Escanea puertos específicos en múltiples hosts
        hosts: lista de direcciones IP
        ports: lista de puertos a escanear
        """
        self.services_info = []  # Limpiar resultados anteriores

        for host in hosts:
            self.console.print(f"\n[yellow]Escaneando puertos en {host}...[/yellow]")

            # Poner los puertos específicos en la cola
            for port in ports:
                self.ports_queue.put((host, port))

            # Crear threads para el escaneo
            threads = []
            for _ in range(min(50, len(ports))):  # Usar máximo 50 threads
                t = threading.Thread(target=self.worker)
                t.daemon = True
                t.start()
                threads.append(t)

            # Esperar a que termine el escaneo
            self.ports_queue.join()

        return self.services_info

    def worker(self):
        while True:
            try:
                host, port = self.ports_queue.get_nowait()
                self.port_scan(host, port)
            except queue.Empty:
                break


class IntegratedScanner:
    def __init__(self):
        self.network_discovery = NetworkDiscovery()
        self.network_scanner = NetworkScanner()
        self.vuln_scanner = VulnerabilityScanner()
        self.console = Console()

    def scan_network_ports(self, network, ports):
        """
        Escanea puertos específicos en toda la red
        network: string en formato CIDR (ej: '192.168.1.0/24')
        ports: lista de puertos a escanear
        """
        # Primero descubrir hosts activos
        active_hosts = self.network_discovery.scan_network(network)

        if not active_hosts:
            self.console.print("[red]No se encontraron hosts activos en la red[/red]")
            return []

        # Luego escanear los puertos específicos en cada host activo
        services = self.network_scanner.scan_specific_ports(active_hosts, ports)

        # Analizar vulnerabilidades
        results = []
        for service_info in services:
            service_name = service_info['service']
            vulnerabilities = self.vuln_scanner.search_cves(service_name)
            results.append({
                'service_info': service_info,
                'vulnerabilities': vulnerabilities
            })

        self.pretty_print(results)
        return results

    def pretty_print(self, results):
        table = Table(title="Resultados del Análisis de Seguridad")
        table.add_column("Host", style="cyan")
        table.add_column("Puerto", style="blue")
        table.add_column("Servicio", style="magenta")
        table.add_column("Banner", style="green")
        table.add_column("CVEs", style="red")

        for result in results:
            service_info = result['service_info']
            vulnerabilities = result['vulnerabilities']

            cves_text = "\n".join([f"{v['cve_id']}: {v.get('cvss', 'N/A')}"
                                   for v in vulnerabilities[:3]])

            table.add_row(
                service_info['host'],
                str(service_info['port']),
                service_info['service'],
                service_info['banner'][:50] + "..." if len(service_info['banner']) > 50 else service_info['banner'],
                cves_text or "Sin vulnerabilidades conocidas",
                end_section=True
            )

        self.console.print(table)


def main():
    scanner = IntegratedScanner()

    # Menú de opciones
    console = Console()
    console.print("\n[bold cyan]Escáner de Red y Vulnerabilidades[/bold cyan]")
    console.print("\n1. Escanear host específico")
    console.print("2. Escanear red completa por puertos específicos")

    option = input("\nSeleccione una opción (1-2): ")

    if option == "1":
        host = input("Ingrese la dirección IP a escanear: ")
        start_port = int(input("Puerto inicial (default: 1): ") or 1)
        end_port = int(input("Puerto final (default: 1024): ") or 1024)
        results = scanner.scan(host, start_port, end_port)
    else:
        network = input("Ingrese la red a escanear (ej: 192.168.1.0/24): ")
        ports_input = input("Ingrese los puertos a escanear (separados por coma): ")
        ports = [int(p.strip()) for p in ports_input.split(",")]
        results = scanner.scan_network_ports(network, ports)

    # Guardar resultados
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    with open(f"scan_results_{timestamp}.json", "w") as f:
        json.dump(results, f, indent=4)


if __name__ == "__main__":
    main()