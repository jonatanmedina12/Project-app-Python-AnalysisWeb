import socket
import threading
import queue
import time
from concurrent.futures import ThreadPoolExecutor
import requests
from bs4 import BeautifulSoup
from rich.console import Console
from rich.table import Table
import json
from datetime import datetime, timedelta


class NetworkScanner:
    def __init__(self):
        self.ports_queue = queue.Queue()
        self.open_ports = []
        self.services_info = []
        self.rate_limit = {'last_request': datetime.now(), 'requests': 0}

    def port_scan(self, host, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            if result == 0:
                try:
                    # Intentar obtener el banner del servicio
                    sock.send(b'GET / HTTP/1.1\r\n\r\n')
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                except:
                    banner = "Banner no disponible"

                service = socket.getservbyport(port, 'tcp')
                self.services_info.append({
                    'port': port,
                    'service': service,
                    'banner': banner
                })
                self.open_ports.append(port)
            sock.close()
        except:
            pass

        self.ports_queue.task_done()

    def scan_ports(self, host, start_port=1, end_port=1024):
        print(f"[+] Iniciando escaneo de puertos en {host}")

        # Poner todos los puertos en la cola
        for port in range(start_port, end_port + 1):
            self.ports_queue.put(port)

        # Crear threads para el escaneo
        for _ in range(100):  # Usar 100 threads
            t = threading.Thread(target=self.worker, args=(host,))
            t.daemon = True
            t.start()

        self.ports_queue.join()
        return self.services_info

    def worker(self, host):
        while True:
            try:
                port = self.ports_queue.get_nowait()
                self.port_scan(host, port)
            except queue.Empty:
                break


class VulnerabilityScanner:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
        }
        self.cache = {}
        self.last_request = datetime.now()
        self.request_count = 0

    def rate_limit(self):
        current_time = datetime.now()
        if (current_time - self.last_request).seconds < 1:
            time.sleep(1)
        self.last_request = current_time

    def search_cve_details(self, cve_info):
        """Busca detalles adicionales de cada CVE"""
        self.rate_limit()  # Control de tasa para las solicitudes

        cve_details_url = f'https://www.cvedetails.com/cve/{cve_info["cve_id"]}/'
        try:
            response = requests.get(cve_details_url, headers=self.headers)
            if response.status_code == 200:
                soup = BeautifulSoup(response.content, 'html.parser')

                # Obtener el valor de CVSS
                cvss_info = soup.find('div', {'class': 'cvssbox'})
                cve_info['cvss'] = cvss_info.getText().strip() if cvss_info else 'No disponible'

                # Agregar la URL
                cve_info['url'] = cve_details_url

                # Intentar convertir CVSS a float
                try:
                    cve_info['cvss'] = float(cve_info['cvss'])
                except (ValueError, TypeError):
                    cve_info['cvss'] = 0.0

        except Exception as e:
            print(f"Error obteniendo detalles para {cve_info['cve_id']}: {str(e)}")
            cve_info['cvss'] = 'Error'
            cve_info['url'] = cve_details_url

    def search_cves(self, service):
        # Verificar cache
        if service in self.cache:
            return self.cache[service]

        self.rate_limit()

        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?KeywordSearch={service}"
        try:
            response = requests.get(url, headers=self.headers)

            if response.status_code != 200:
                print(f"Error en la solicitud a NVD API: {response.status_code}")
                return []

            data_dict = response.json()
            cves_info = []

            for vulnerability in data_dict.get('vulnerabilities', []):
                cve = vulnerability.get('cve', {})
                cve_id = cve.get('id')
                descriptions = cve.get('descriptions', [])
                description = next((desc['value'] for desc in descriptions if desc.get('lang') == 'es'), None)

                if cve_id and description:
                    cves_info.append({
                        'cve_id': cve_id,
                        'description': description
                    })

            # Obtener detalles adicionales usando ThreadPoolExecutor
            with ThreadPoolExecutor(max_workers=5) as executor:
                list(executor.map(self.search_cve_details, cves_info))

            # Guardar en cache
            self.cache[service] = cves_info
            return cves_info

        except Exception as e:
            print(f"Error buscando CVEs para {service}: {str(e)}")
            return []

class IntegratedScanner:
    def __init__(self):
        self.network_scanner = NetworkScanner()
        self.vuln_scanner = VulnerabilityScanner()
        self.console = Console()

    def scan(self, host, start_port=1, end_port=1024):
        # Paso 1: Escaneo de red
        services = self.network_scanner.scan_ports(host, start_port, end_port)

        # Paso 2: Análisis de vulnerabilidades
        results = []
        for service_info in services:
            service_name = service_info['service']
            vulnerabilities = self.vuln_scanner.search_cves(service_name)
            results.append({
                'service_info': service_info,
                'vulnerabilities': vulnerabilities
            })

        self.pretty_print(results)
        return results

    def pretty_print(self, results):
        table = Table(title="Resultados del Análisis de Seguridad")
        table.add_column("Puerto", style="cyan")
        table.add_column("Servicio", style="blue")
        table.add_column("Banner", style="magenta")
        table.add_column("CVEs", style="red")
        table.add_column("CVSS", style="yellow")

        for result in results:
            service_info = result['service_info']
            vulnerabilities = result['vulnerabilities']

            # Formatear vulnerabilidades para mostrar
            cves_text = "\n".join([f"{v['cve_id']}: {v.get('cvss', 'N/A')}"
                                   for v in vulnerabilities[:3]])  # Mostrar solo top 3

            table.add_row(
                str(service_info['port']),
                service_info['service'],
                service_info['banner'][:50] + "..." if len(service_info['banner']) > 50 else service_info['banner'],
                cves_text or "Sin vulnerabilidades conocidas",
                "",
                end_section=True
            )

        self.console.print(table)


def main():
    scanner = IntegratedScanner()
    host = input("Ingrese la dirección IP a escanear: ")
    start_port = int(input("Puerto inicial (default: 1): ") or 1)
    end_port = int(input("Puerto final (default: 1024): ") or 1024)

    results = scanner.scan(host, start_port, end_port)

    # Guardar resultados en un archivo
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    with open(f"scan_results_{timestamp}.json", "w") as f:
        json.dump(results, f, indent=4)


if __name__ == "__main__":
    main()